package com.firas.generator.stack.spring;

import com.firas.generator.model.*;
import com.firas.generator.model.config.*;
import com.firas.generator.service.TemplateService;
import org.springframework.stereotype.Component;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Generator for Spring Cloud microservices architecture.
 *
 * Produces a multi-module Maven project with:
 * - Parent POM aggregating all modules
 * - Eureka Discovery Server
 * - Spring Cloud Config Server
 * - API Gateway (Spring Cloud Gateway)
 * - Per-service modules with CRUD code generated by {@link SpringCodeGenerator}
 * - Feign clients for cross-service communication
 * - Docker Compose (optional)
 *
 * @author Firas Baklouti
 * @version 1.0
 * @since 2025-12-07
 */
@Component
public class MicroservicesGenerator {

    private static final String TEMPLATE_DIR = "spring/microservices/";

    private final TemplateService templateService;
    private final SpringCodeGenerator codeGenerator;

    public MicroservicesGenerator(TemplateService templateService, SpringCodeGenerator codeGenerator) {
        this.templateService = templateService;
        this.codeGenerator = codeGenerator;
    }

    // ==================== Service Definition Computation ====================

    /**
     * Computes the list of {@link ServiceDefinition} objects based on the microservices
     * configuration mode (AUTO or MANUAL).
     *
     * <p>AUTO mode creates one service per non-join table. The service name is derived
     * by singularizing and lowercasing the table name with a "-service" suffix.
     *
     * <p>MANUAL mode uses the {@code serviceTableMapping} from {@link MicroservicesConfig}
     * to group tables into user-defined services.
     *
     * @param request the project request containing tables and configuration
     * @return list of service definitions with port assignments
     */
    public List<ServiceDefinition> computeServiceDefinitions(ProjectRequest request) {
        SpringConfig springConfig = request.getEffectiveSpringConfig();
        MicroservicesConfig msConfig = springConfig.getMicroservicesConfig();
        if (msConfig == null) {
            msConfig = new MicroservicesConfig();
        }

        List<Table> allTables = request.getTables() != null ? request.getTables() : Collections.emptyList();
        String basePackage = request.getPackageName();
        int port = msConfig.getServiceStartPort();

        List<ServiceDefinition> services = new ArrayList<>();

        if ("MANUAL".equalsIgnoreCase(msConfig.getMode()) && msConfig.getServiceTableMapping() != null
                && !msConfig.getServiceTableMapping().isEmpty()) {
            // MANUAL mode: user-defined service-to-table grouping
            Map<String, List<String>> mapping = msConfig.getServiceTableMapping();
            for (Map.Entry<String, List<String>> entry : mapping.entrySet()) {
                String serviceName = entry.getKey();
                List<String> tableNames = entry.getValue();

                List<Table> serviceTables = allTables.stream()
                        .filter(t -> tableNames.stream().anyMatch(tn -> tn.equalsIgnoreCase(t.getName())))
                        .collect(Collectors.toList());

                String artifactId = serviceName;
                String servicePackage = basePackage + "." + serviceName.replace("-", "");

                services.add(new ServiceDefinition(serviceName, artifactId, port++, serviceTables, servicePackage));
            }
        } else {
            // AUTO mode: one service per non-join table
            for (Table table : allTables) {
                if (table.isJoinTable()) {
                    continue;
                }
                String singularName = singularize(table.getName().toLowerCase());
                String serviceName = singularName + "-service";
                String artifactId = serviceName;
                String servicePackage = basePackage + "." + serviceName.replace("-", "");

                services.add(new ServiceDefinition(serviceName, artifactId, port++,
                        Collections.singletonList(table), servicePackage));
            }
        }

        return services;
    }

    // ==================== Project Generation ====================

    /**
     * Generates the complete microservices project structure.
     *
     * @param request the project request
     * @return list of all generated file previews
     */
    public List<FilePreview> generateMicroservicesProject(ProjectRequest request) {
        List<FilePreview> files = new ArrayList<>();

        SpringConfig springConfig = request.getEffectiveSpringConfig();
        MicroservicesConfig msConfig = springConfig.getMicroservicesConfig();
        if (msConfig == null) {
            msConfig = new MicroservicesConfig();
        }

        List<ServiceDefinition> services = computeServiceDefinitions(request);

        // Build shared template model
        Map<String, Object> baseModel = buildBaseModel(request, springConfig, msConfig, services);

        // 1. Parent POM
        files.add(generateParentPom(baseModel));

        // 2. Discovery Server (Eureka)
        files.addAll(generateDiscoveryServer(baseModel, request));

        // 3. Config Server
        files.addAll(generateConfigServer(baseModel, request));

        // 4. API Gateway
        files.addAll(generateApiGateway(baseModel, request, services));

        // 5. Per-service modules
        for (ServiceDefinition service : services) {
            files.addAll(generateServiceModule(service, request, springConfig, msConfig, services));
        }

        // 6. Docker Compose
        if (request.isIncludeDocker()) {
            files.add(generateDockerCompose(baseModel, request));
        }

        // 7. Root .gitignore
        files.add(generateGitignore());

        return files;
    }

    // ==================== Infrastructure Modules ====================

    private FilePreview generateParentPom(Map<String, Object> model) {
        String content = templateService.processTemplateToString(TEMPLATE_DIR + "parent-pom.xml.ftl", model);
        return new FilePreview("pom.xml", content, "xml");
    }

    private List<FilePreview> generateDiscoveryServer(Map<String, Object> model, ProjectRequest request) {
        List<FilePreview> files = new ArrayList<>();
        String module = "discovery-server";

        files.add(processInfraTemplate(module, "pom.xml.ftl", "pom.xml", "xml", model));
        files.add(generateInfraApplication(module, "DiscoveryServer", request, model));
        files.add(processInfraTemplate(module, "application.yml.ftl",
                "src/main/resources/application.yml", "yaml", model));

        return files;
    }

    private List<FilePreview> generateConfigServer(Map<String, Object> model, ProjectRequest request) {
        List<FilePreview> files = new ArrayList<>();
        String module = "config-server";

        files.add(processInfraTemplate(module, "pom.xml.ftl", "pom.xml", "xml", model));
        files.add(generateInfraApplication(module, "ConfigServer", request, model));
        files.add(processInfraTemplate(module, "application.yml.ftl",
                "src/main/resources/application.yml", "yaml", model));

        return files;
    }

    private List<FilePreview> generateApiGateway(Map<String, Object> model, ProjectRequest request,
                                                  List<ServiceDefinition> services) {
        List<FilePreview> files = new ArrayList<>();
        String module = "api-gateway";

        Map<String, Object> gatewayModel = new HashMap<>(model);
        gatewayModel.put("services", services);

        files.add(processInfraTemplate(module, "pom.xml.ftl", "pom.xml", "xml", gatewayModel));
        files.add(generateInfraApplication(module, "ApiGateway", request, gatewayModel));
        files.add(processInfraTemplate(module, "application.yml.ftl",
                "src/main/resources/application.yml", "yaml", gatewayModel));

        return files;
    }

    /**
     * Processes an infrastructure module template and prefixes the output path with the module name.
     */
    private FilePreview processInfraTemplate(String module, String templateFile,
                                              String outputPath, String language,
                                              Map<String, Object> model) {
        String content = templateService.processTemplateToString(
                TEMPLATE_DIR + module + "/" + templateFile, model);
        return new FilePreview(module + "/" + outputPath, content, language);
    }

    /**
     * Generates the Spring Boot Application class for an infrastructure module.
     */
    private FilePreview generateInfraApplication(String module, String className,
                                                  ProjectRequest request, Map<String, Object> model) {
        Map<String, Object> appModel = new HashMap<>(model);
        appModel.put("className", className + "Application");

        String packagePath = request.getPackageName().replace(".", "/");
        String content = templateService.processTemplateToString(
                TEMPLATE_DIR + module + "/Application.java.ftl", appModel);
        String path = module + "/src/main/java/" + packagePath + "/" + className + "Application.java";
        return new FilePreview(path, content, "java");
    }

    // ==================== Per-Service Module Generation ====================

    /**
     * Generates all files for a single microservice module.
     */
    private List<FilePreview> generateServiceModule(ServiceDefinition service,
                                                     ProjectRequest request,
                                                     SpringConfig springConfig,
                                                     MicroservicesConfig msConfig,
                                                     List<ServiceDefinition> allServices) {
        List<FilePreview> files = new ArrayList<>();
        String moduleName = service.getServiceName();

        // Build service-specific model
        Map<String, Object> model = new HashMap<>();
        model.put("request", request);
        model.put("springConfig", springConfig);
        model.put("service", service);
        model.put("services", allServices);
        model.put("tables", service.getTables());
        model.put("groupId", springConfig.getGroupId());
        model.put("artifactId", service.getArtifactId());
        model.put("packageName", service.getPackageName());
        model.put("discoveryPort", msConfig.getDiscoveryPort());
        model.put("configPort", msConfig.getConfigPort());
        model.put("gatewayPort", msConfig.getGatewayPort());
        addDatabaseFlags(model, request);
        addSecurityFlags(model, request);

        // Service pom.xml
        String pomContent = templateService.processTemplateToString(
                TEMPLATE_DIR + "service/pom.xml.ftl", model);
        files.add(new FilePreview(moduleName + "/pom.xml", pomContent, "xml"));

        // Service application.yml
        String ymlContent = templateService.processTemplateToString(
                TEMPLATE_DIR + "service/application.yml.ftl", model);
        files.add(new FilePreview(moduleName + "/src/main/resources/application.yml", ymlContent, "yaml"));

        // Service Application.java
        String appClassName = toClassName(service.getServiceName()) + "Application";
        Map<String, Object> appModel = new HashMap<>(model);
        appModel.put("className", appClassName);
        String appContent = templateService.processTemplateToString(
                TEMPLATE_DIR + "service/Application.java.ftl", appModel);
        String packagePath = service.getPackageName().replace(".", "/");
        files.add(new FilePreview(
                moduleName + "/src/main/java/" + packagePath + "/" + appClassName + ".java",
                appContent, "java"));

        // Configure code generator with the request's Spring and security settings
        codeGenerator.setSpringConfig(springConfig);
        if (request.getSecurityConfig() != null && request.getSecurityConfig().isEnabled()) {
            codeGenerator.setSecurityConfig(request.getSecurityConfig());
        }

        try {
            // Generate CRUD code for each table in this service
            for (Table table : service.getTables()) {
                if (table.isJoinTable()) {
                    continue;
                }
                generateCrudForTable(table, service, request, moduleName, files);
            }

            // Generate Feign clients for cross-service relationships
            List<FilePreview> feignClients = generateFeignClients(service, allServices, request);
            files.addAll(feignClients);
        } finally {
            codeGenerator.clearConfig();
        }

        return files;
    }

    /**
     * Generates all CRUD files for a single table within a service module, prefixing each
     * file path with the service module directory.
     */
    private void generateCrudForTable(Table table, ServiceDefinition service,
                                       ProjectRequest request, String moduleName,
                                       List<FilePreview> files) {
        String pkg = service.getPackageName();

        if (request.isIncludeEntity()) {
            files.add(prefixPath(moduleName, codeGenerator.generateEntity(table, pkg)));
        }
        if (request.isIncludeRepository()) {
            files.add(prefixPath(moduleName, codeGenerator.generateRepository(table, pkg)));
        }
        if (request.isIncludeService()) {
            files.add(prefixPath(moduleName, codeGenerator.generateService(table, pkg)));
        }
        if (request.isIncludeController()) {
            files.add(prefixPath(moduleName, codeGenerator.generateController(table, pkg)));
        }
        if (request.isIncludeDto() || request.isIncludeController() || request.isIncludeService()) {
            files.add(prefixPath(moduleName, codeGenerator.generateDto(table, pkg)));
        }
        if (request.isIncludeMapper() || request.isIncludeDto()
                || request.isIncludeController() || request.isIncludeService()) {
            files.add(prefixPath(moduleName, codeGenerator.generateMapper(table, pkg)));
        }
    }

    // ==================== Feign Client Generation ====================

    /**
     * Detects cross-service relationships and generates {@code @FeignClient} interfaces.
     *
     * <p>If table A in service X has a relationship referencing table B in service Y,
     * a Feign client interface is generated in service X to call service Y's REST API.
     */
    private List<FilePreview> generateFeignClients(ServiceDefinition currentService,
                                                    List<ServiceDefinition> allServices,
                                                    ProjectRequest request) {
        List<FilePreview> files = new ArrayList<>();
        String moduleName = currentService.getServiceName();

        // Collect table names owned by the current service
        Set<String> ownedTableNames = currentService.getTables().stream()
                .map(t -> t.getName().toLowerCase())
                .collect(Collectors.toSet());

        // Track which remote services we've already generated a Feign client for
        Set<String> generatedClients = new HashSet<>();

        for (Table table : currentService.getTables()) {
            for (Relationship rel : table.getRelationships()) {
                String targetTableName = rel.getTargetTable();
                if (targetTableName == null || ownedTableNames.contains(targetTableName.toLowerCase())) {
                    continue; // Same service — no Feign client needed
                }

                // Find which service owns the target table
                ServiceDefinition targetService = findServiceForTable(targetTableName, allServices);
                if (targetService == null || targetService.getServiceName().equals(currentService.getServiceName())) {
                    continue;
                }

                String clientKey = targetService.getServiceName();
                if (generatedClients.contains(clientKey)) {
                    continue;
                }
                generatedClients.add(clientKey);

                // Find the target table object for class name resolution
                Table targetTable = targetService.getTables().stream()
                        .filter(t -> t.getName().equalsIgnoreCase(targetTableName))
                        .findFirst()
                        .orElse(null);
                if (targetTable == null) {
                    continue;
                }

                Map<String, Object> model = new HashMap<>();
                model.put("packageName", currentService.getPackageName());
                model.put("targetServiceName", targetService.getServiceName());
                model.put("targetTable", targetTable);
                model.put("request", request);

                String content = templateService.processTemplateToString(
                        TEMPLATE_DIR + "service/FeignClient.java.ftl", model);

                String clientClassName = toClassName(targetService.getServiceName().replace("-service", ""))
                        + "ServiceClient";
                String packagePath = currentService.getPackageName().replace(".", "/");
                String path = moduleName + "/src/main/java/" + packagePath + "/client/"
                        + clientClassName + ".java";
                files.add(new FilePreview(path, content, "java"));
            }
        }

        return files;
    }

    /**
     * Finds the service definition that owns the given table name.
     */
    private ServiceDefinition findServiceForTable(String tableName, List<ServiceDefinition> services) {
        for (ServiceDefinition svc : services) {
            for (Table t : svc.getTables()) {
                if (t.getName().equalsIgnoreCase(tableName)) {
                    return svc;
                }
            }
        }
        return null;
    }

    // ==================== Docker & Gitignore ====================

    private FilePreview generateDockerCompose(Map<String, Object> baseModel, ProjectRequest request) {
        Map<String, Object> model = new HashMap<>(baseModel);
        addDatabaseFlags(model, request);
        addSecurityFlags(model, request);

        String content = templateService.processTemplateToString(
                TEMPLATE_DIR + "docker-compose.yml.ftl", model);
        return new FilePreview("docker-compose.yml", content, "yaml");
    }

    private FilePreview generateGitignore() {
        String content = templateService.processTemplateToString("spring/.gitignore.ftl", new HashMap<>());
        return new FilePreview(".gitignore", content, "text");
    }

    // ==================== Model Builders ====================

    /**
     * Builds the shared base model used across infrastructure and service templates.
     */
    private Map<String, Object> buildBaseModel(ProjectRequest request, SpringConfig springConfig,
                                                MicroservicesConfig msConfig,
                                                List<ServiceDefinition> services) {
        Map<String, Object> model = new HashMap<>();
        model.put("request", request);
        model.put("springConfig", springConfig);
        model.put("services", services);
        model.put("groupId", springConfig.getGroupId());
        model.put("artifactId", springConfig.getArtifactId());
        model.put("packageName", request.getPackageName());
        model.put("discoveryPort", msConfig.getDiscoveryPort());
        model.put("configPort", msConfig.getConfigPort());
        model.put("gatewayPort", msConfig.getGatewayPort());
        addDatabaseFlags(model, request);
        addSecurityFlags(model, request);
        return model;
    }

    /**
     * Adds database-type boolean flags to the template model.
     */
    private void addDatabaseFlags(Map<String, Object> model, ProjectRequest request) {
        List<DependencyMetadata> deps = request.getDependencies();
        model.put("hasMysql", hasDep(deps, "mysql", "mysql"));
        model.put("hasPostgres", hasDep(deps, "postgresql", "postgresql"));
        model.put("hasMariadb", hasDep(deps, "mariadb", "mariadb"));
        model.put("hasRedis", hasDep(deps, "data-redis", "redis"));
        model.put("hasMongodb", hasDep(deps, "data-mongodb", "mongo"));
    }

    /**
     * Adds security-related flags to the template model.
     */
    private void addSecurityFlags(Map<String, Object> model, ProjectRequest request) {
        SecurityConfig sec = request.getSecurityConfig();
        boolean hasSecurity = sec != null && sec.isEnabled();
        boolean hasJwt = hasSecurity && "JWT".equalsIgnoreCase(sec.getAuthenticationType());
        model.put("hasSecurity", hasSecurity);
        model.put("hasJwt", hasJwt);
    }

    // ==================== Utility Methods ====================

    /**
     * Checks whether a dependency list contains a dependency matching the given id or
     * an artifactId containing the given fragment.
     */
    private boolean hasDep(List<DependencyMetadata> deps, String id, String artifactFragment) {
        if (deps == null) return false;
        return deps.stream().anyMatch(d ->
                id.equals(d.getId())
                        || (d.getArtifactId() != null && d.getArtifactId().contains(artifactFragment)));
    }

    /**
     * Prefixes a {@link FilePreview} path with a module directory name.
     */
    private FilePreview prefixPath(String moduleName, FilePreview preview) {
        return new FilePreview(moduleName + "/" + preview.getPath(), preview.getContent(), preview.getLanguage());
    }

    /**
     * Converts a hyphenated or spaced name to a PascalCase Java class name.
     */
    private String toClassName(String name) {
        if (name == null || name.isEmpty()) return "Demo";
        StringBuilder sb = new StringBuilder();
        for (String part : name.split("[\\-_ ]+")) {
            if (!part.isEmpty()) {
                sb.append(Character.toUpperCase(part.charAt(0)));
                if (part.length() > 1) {
                    sb.append(part.substring(1).toLowerCase());
                }
            }
        }
        String result = sb.toString();
        return result.isEmpty() ? "Demo" : result;
    }

    /**
     * Naive English singularization for table-name → service-name conversion.
     * Handles common plural suffixes; returns the input unchanged for ambiguous cases.
     */
    private String singularize(String name) {
        if (name == null || name.length() <= 2) return name;
        if (name.endsWith("ies")) {
            return name.substring(0, name.length() - 3) + "y";
        }
        if (name.endsWith("ses") || name.endsWith("xes") || name.endsWith("zes")
                || name.endsWith("ches") || name.endsWith("shes")) {
            return name.substring(0, name.length() - 2);
        }
        if (name.endsWith("s") && !name.endsWith("ss")) {
            return name.substring(0, name.length() - 1);
        }
        return name;
    }
}
